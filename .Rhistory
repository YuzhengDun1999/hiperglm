result = c(result, sample_var_with_question_mark)
}
hist(result)
#' Approximate derivative via centered-difference approximation
approximate_deriv <- function(func, x, dx) {
# Fill in
(func(x + dx) - func(x - dx)) /(2 * dx)
}
log_logistic_func <- function(x) {
# Fill in
log(exp(x) / (1 + exp(x)))
}
log_logistic_deriv <- function(x) {
# Fill in
1 / (1 + exp(x))
}
# Calculate and plot the relative errors of finite difference approximations
set.seed(615)
x <- rnorm(1)
log2_dx <- - seq(1, 52)
numerical_deriv <- sapply(
2^log2_dx, function(dx) approximate_deriv(log_logistic_func, x, dx)
)
analytical_deriv <- log_logistic_deriv(x)
rel_err <- abs(
(analytical_deriv - numerical_deriv) / analytical_deriv
)
fontsize <- 1.2
plot(
log2_dx, log2(rel_err),
frame = FALSE, # Remove the ugly box
col = jhu_color$spiritBlue,
xlab = "log2 stepsize for finite difference",
ylab = "log2 rel errors",
xlim = rev(range(log2_dx)),
cex.lab = fontsize,
cex.axis = fontsize,
type = 'l'
)
approximate_deriv <- function(func, x, dx) {
# Fill in
(func(x+dx)-func(x-dx))/2/dx
}
log_logistic_func <- function(x) {
# Fill in
log(exp(x)/(1+exp(x)))
}
log_logistic_deriv <- function(x) {
# Fill in
1/(1+exp(x))
}
# Calculate and plot the relative errors of finite difference approximations
set.seed(615)
x <- rnorm(1)
log2_dx <- - seq(1, 52)
numerical_deriv <- sapply(
2^log2_dx, function(dx) approximate_deriv(log_logistic_func, x, dx)
)
analytical_deriv <- log_logistic_deriv(x)
rel_err <- abs(
(analytical_deriv - numerical_deriv) / analytical_deriv
)
fontsize <- 1.2
plot(
log2_dx, log2(rel_err),
frame = FALSE, # Remove the ugly box
col = jhu_color$spiritBlue,
xlab = "log2 stepsize for finite difference",
ylab = "log2 rel errors",
xlim = rev(range(log2_dx)),
cex.lab = fontsize,
cex.axis = fontsize,
type = 'l'
)
set.seed(410)
n_param <- 4
X <- matrix(rnorm(2 * n_param^2), nrow = 2 * n_param, ncol = n_param)
Sigma_inv <- t(X) %*% X
eigen(Sigma_inv, symmetric = TRUE)
eigenval=eigen(Sigma_inv, symmetric = TRUE)
eigen_decom = eigen(Sigma_inv)
eigenval=eigen_decom$values
eigenval=eigen_decom$vectors
eigenval=eigen_decom$values
eigenvec=eigen_decom$values
t(eigenvec)
eigenvec=eigen_decom$vectors
eigenvec
t(eigenvec) %*% diag(eigenval) %*% eigenvec
Sigma_inv
eigenvec %*% diag(eigenval) %*% t(eigenvec)
eigen_decomp = eigen(Sigma_inv)
Sigma_inv_sqrt = eigen_decomp$vectors %*% diag(sqrt(eigen_decomp$values)) %*% t(eigen_decomp$vectors)
Sigma_inv_sqrt
Sigma_inv_sqrt%*% t(Sigma_inv_sqrt)
Sigma_inv
approx_grad <- function(func, x, dx = .Machine$double.eps^(1/3)) {
numerical_grad <- rep(0, length(x))
# Fill in
for (i in 1:length(x)) {
x_plus_dx = x
x_plus_dx[i] = x_plus_dx[i] + dx
numerical_grad[i] = (func(x_plus_dx) - func(x)) / dx
}
return(numerical_grad)
}
set.seed(410)
n_param <- 4
X <- matrix(rnorm(2 * n_param^2), nrow = 2 * n_param, ncol = n_param)
Sigma_inv <- t(X) %*% X
#' Calculate log-density of centered Gaussian up to an additive factor
gaussian_logp <- function(x, Sigma_inv) {
logp <- - .5 * t(x) %*% Sigma_inv %*% x
return(logp)
}
gaussian_grad <- function(x, Sigma_inv) {
grad = -Sigma_inv %*% x
return(grad)
}
x <- c(3, 1, 4, 1)
analytical_grad <- gaussian_grad(x, Sigma_inv)
numerical_grad <- approx_grad(function(x) gaussian_logp(x, Sigma_inv), x)
analytical_grad
numerical_grad
gaussian_grad <- function(x, Sigma_inv) {
grad = -Sigma_inv %*% x
grad = grad[,1]
return(grad)
}
x <- c(3, 1, 4, 1)
analytical_grad <- gaussian_grad(x, Sigma_inv)
numerical_grad <- approx_grad(function(x) gaussian_logp(x, Sigma_inv), x)
analytical_grad
numerical_grad
testthat::expect_true(are_all_close(
analytical_grad, numerical_grad, abs_tol = Inf, rel_tol = 1e-3
))
testthat::expect_true(are_all_close(
analytical_grad, numerical_grad, abs_tol = Inf, rel_tol = 1e-3
))
are_all_close(
analytical_grad, numerical_grad, abs_tol = Inf, rel_tol = 1e-3
)
testthat::expect_true(are_all_close(
analytical_grad, numerical_grad, abs_tol = Inf, rel_tol = 1e-3
))
testthat::expect_true(!are_all_close(
analytical_grad, numerical_grad, abs_tol = Inf, rel_tol = 1e-3
))
#' Approximate derivative via centered-difference approximation
approximate_deriv <- function(func, x, dx) {
# Fill in
(func(x + dx) - func(x - dx)) /(2 * dx)
}
log_logistic_func <- function(x) {
# Fill in
log(exp(x) / (1 + exp(x)))
}
log_logistic_deriv <- function(x) {
# Fill in
1 / (1 + exp(x))
}
# Calculate and plot the relative errors of finite difference approximations
set.seed(615)
x <- rnorm(1)
log2_dx <- - seq(1, 52)
numerical_deriv <- sapply(
2^log2_dx, function(dx) approximate_deriv(log_logistic_func, x, dx)
)
analytical_deriv <- log_logistic_deriv(x)
rel_err <- abs(
(analytical_deriv - numerical_deriv) / analytical_deriv
)
fontsize <- 1.2
plot(
log2_dx, log2(rel_err),
frame = FALSE, # Remove the ugly box
col = jhu_color$spiritBlue,
xlab = "log2 stepsize for finite difference",
ylab = "log2 rel errors",
xlim = rev(range(log2_dx)),
cex.lab = fontsize,
cex.axis = fontsize,
type = 'l'
)
log2_dx<-as.numeric(log2_dx)
log2_rel_err<-as.numeric(log2(rel_err))
min_rel_pos<-which.min(log2_rel_err)
df<-data.frame(step = log2_dx[min_rel_pos:length(log2_rel_err)], rel=log2_rel_err[min_rel_pos:length(log2_rel_err)])
reg<-lm(rel~step,df)
summary(reg)
approximate_deriv <- function(func, x, dx) {
approx_deriv_out <- (func(x+dx)-func(x-dx))/(2*dx)
return(approx_deriv_out)
}
log_logistic_func <- function(x) {
log_logistic_func_out <- log(exp(x)/(1+exp(x)))
return(log_logistic_func_out)
}
log_logistic_deriv <- function(x) {
# The derivative can be found using this following commands
# f = expression(log(exp(x)/(1+exp(x))))
# f_deriv <- D(f,"x")
log_logistic_deriv_out <- (exp(x)/(1 + exp(x)) - exp(x) * exp(x)/(1 + exp(x))^2)/(exp(x)/(1 + exp(x)))
return(log_logistic_deriv_out)
}
# Calculate and plot the relative errors of finite difference approximations
set.seed(615)
x <- rnorm(1)
log2_dx <- - seq(1, 52)
numerical_deriv <- sapply(
2^log2_dx, function(dx) approximate_deriv(log_logistic_func, x, dx)
)
analytical_deriv <- log_logistic_deriv(x)
rel_err <- abs(
(analytical_deriv - numerical_deriv) / analytical_deriv
)
fontsize <- 1.2
plot(
log2_dx, log2(rel_err),
frame = FALSE, # Remove the ugly box
col = "red",
xlab = "log2 stepsize for finite difference",
ylab = "log2 rel errors",
xlim = rev(range(log2_dx)),
cex.lab = fontsize,
cex.axis = fontsize,
type = 'l'
)
getwd()
approx_grad <- function(func, x, dx = .Machine$double.eps^(1/3)) {
numerical_grad <- rep(0, length(x))
# Fill in
for (i in 1:length(x)) {
x_plus_dx = x
x_plus_dx[i] = x_plus_dx[i] + dx
numerical_grad[i] = (func(x_plus_dx) - func(x)) / dx
}
return(numerical_grad)
}
set.seed(410)
n_param <- 4
X <- matrix(rnorm(2 * n_param^2), nrow = 2 * n_param, ncol = n_param)
Sigma_inv <- t(X) %*% X
#' Calculate log-density of centered Gaussian up to an additive factor
gaussian_logp <- function(x, Sigma_inv) {
logp <- - .5 * t(x) %*% Sigma_inv %*% x
return(logp)
}
gaussian_grad <- function(x, Sigma_inv) {
grad = -Sigma_inv %*% x
grad = grad[,1]
return(grad)
}
x <- c(3, 1, 4, 1)
analytical_grad <- gaussian_grad(x, Sigma_inv)
numerical_grad <- approx_grad(function(x) gaussian_logp(x, Sigma_inv), x)
testthat::expect_true(are_all_close(
analytical_grad, numerical_grad, abs_tol = Inf, rel_tol = 1e-3
))
are_all_close <- function(v, w, abs_tol = 1e-6, rel_tol = 1e-6) {
abs_diff <- abs(v - w)
are_all_within_atol <- all(abs_diff < abs_tol)
are_all_within_rtol <- all(abs_diff < rel_tol * pmax(abs(v), abs(w)))
return(are_all_within_atol && are_all_within_rtol)
}
testthat::expect_true(are_all_close(
analytical_grad, numerical_grad, abs_tol = Inf, rel_tol = 1e-3
))
are_all_close <- function(v, w, abs_tol = 1e-6, rel_tol = 1e-6) {
abs_diff <- abs(v - w)
are_all_within_atol <- all(abs_diff < abs_tol)
are_all_within_rtol <- all(abs_diff < rel_tol * pmax(abs(v), abs(w)))
return(are_all_within_atol && are_all_within_rtol)
}
test_that("linalg and optim least-sq coincide", {
n_obs <- 32; n_pred <- 4
data <- simulate_data(n_obs, n_pred, model = 'linear', seed = 1918)
design <- data$design; outcome <- data$outcome
via_linalg_out <- hiper_glm(design, outcome, model = 'linear')
via_bfgs_out <- hiper_glm(
design, outcome, model = 'linear', option = list(mle_solver = 'BFGS')
)
expect_true(are_all_close(
coef(via_linalg_out), coef(via_bfgs_out), abs_tol = 1e-2, rel_tol = 1e-2
))
})
help("testthat")
devtools::load_all(".")
help(test_that)
are_all_close
are_all_close
help("runif")
set.seed(100)
x = runif(100, min = 1, max = 10)
y = x + 10 ** (-5)
x_y_close <- are_all_close(x, y)
x_y_close
x_y_close <- are_all_close(x, y, abs_tol = 1e-3, rel_tol = 1e-3)
x_y_close
are_all_close
set.seed(100)
x = runif(100, min = 1, max = 10)
y = x + 10 ** (-8)
x_y_close <- are_all_close(x, y)
testthat::expect_true(
are_all_close(x, y)
)
testthat::test_that(
"Return True when two vectors are close",
{
set.seed(100)
x = runif(100, min = 1, max = 10)
y = x + 10 ** (-8)
x_y_close <- are_all_close(x, y)
testthat::expect_true(
are_all_close(x, y)
)
}
)
help(pmax)
testthat::test_that(
"Return True when two vectors are close", {
set.seed(100)
x = runif(100, min = 1, max = 10)
y = x + 1e-8
x_y_close <- are_all_close(x, y)
testthat::expect_true(
are_all_close(x, y)
)
}
)
set.seed(100)
abs_tol = 1e-5
rel_tol = 1e-9
x = runif(100, min = 1, max = 10)
y = x + 1e-6
x_y_close <- are_all_close(x, y, abs_tol, rel_tol)
x_y_close
testthat::test_that(
"Return False when relative error is above rel_tol", {
set.seed(100)
abs_tol = 1e-5
rel_tol = 1e-9
x = runif(100, min = 1, max = 10)
y = x + 1e-6
x_y_close <- are_all_close(x, y, abs_tol, rel_tol)
testthat::expect_false(
are_all_close(x, y, abs_tol, rel_tol)
)
}
)
set.seed(100)
abs_tol = 1e-9
rel_tol = 1e-3
x = runif(100, min = 1, max = 10)
y = x + 1e-7
x_y_close <- are_all_close(x, y, abs_tol, rel_tol)
x_y_close
testthat::test_that(
"Return False when absolute error is above abs_tol", {
set.seed(100)
abs_tol = 1e-9
rel_tol = 1e-3
x = runif(100, min = 1, max = 10)
y = x + 1e-7
x_y_close <- are_all_close(x, y, abs_tol, rel_tol)
testthat::expect_false(
are_all_close(x, y, abs_tol, rel_tol)
)
}
)
test_that(
"test for the gradient of log likelihood in linear model", {
n_obs = 32; n_pred = 4
data = simulate_data(n_obs, n_pred, model = 'linear', seed = 1918)
design = data$design; outcome = data$outcome
beta = c(3, 1, 4, 1)
analytical_grad <- lm_gradient(beta, design, outcome)
numerical_grad <- approx_grad(function(beta) lm_log_likelihood(beta, design, outcome), beta)
expect_true(
are_all_close(analytical_grad, numerical_grad, abs_tol = 1e-3, rel_tol = 1e-3)
)
}
)
devtools::load_all(".")
test_that(
"test for the gradient of log likelihood in linear model", {
n_obs = 32; n_pred = 4
data = simulate_data(n_obs, n_pred, model = 'linear', seed = 1918)
design = data$design; outcome = data$outcome
beta = c(3, 1, 4, 1)
analytical_grad <- lm_gradient(beta, design, outcome)
numerical_grad <- approx_grad(function(beta) lm_log_likelihood(beta, design, outcome), beta)
expect_true(
are_all_close(analytical_grad, numerical_grad, abs_tol = 1e-3, rel_tol = 1e-3)
)
}
)
analytical_grad
numerical_grad
lm_gradient(beta, design, outcome)
n_obs = 32; n_pred = 4
data = simulate_data(n_obs, n_pred, model = 'linear', seed = 1918)
design = data$design; outcome = data$outcome
beta = c(3, 1, 4, 1)
analytical_grad <- lm_gradient(beta, design, outcome)
numerical_grad <- approx_grad(function(beta) lm_log_likelihood(beta, design, outcome), beta)
analytical_grad
numerical_grad
devtools::load_all(".")
test_that(
"test for the gradient of log likelihood in linear model", {
n_obs = 32; n_pred = 4
data = simulate_data(n_obs, n_pred, model = 'linear', seed = 1918)
design = data$design; outcome = data$outcome
beta = c(3, 1, 4, 1)
analytical_grad <- lm_gradient(beta, design, outcome)
numerical_grad <- approx_grad(function(beta) lm_log_likelihood(beta, design, outcome), beta)
testthat::expect_true(
are_all_close(analytical_grad, numerical_grad, abs_tol = 1e-3, rel_tol = 1e-3)
)
}
)
n_obs = 32; n_pred = 4
data = simulate_data(n_obs, n_pred, model = 'linear', seed = 1918)
design = data$design; outcome = data$outcome
beta = c(3, 1, 4, 1)
analytical_grad <- lm_gradient(beta, design, outcome)
numerical_grad <- approx_grad(function(beta) lm_log_likelihood(beta, design, outcome), beta)
analytical_grad
numerical_grad
lm_log_likelihood1 <- function(coef,design,outcome,noise_var=1){
prediction <- design %*% coef
residual <- outcome - prediction
return(sum(-residual^2/noise_var/2))
}
lm_log_likelihood(beta,design,outcome)
lm_log_likelihood1(beta,design,outcome)
devtools::load_all(".")
lm_log_likelihood(beta,design,outcome)
lm_log_likelihood1(beta,design,outcome)
lm_loglike_grad <- function(coef,design,outcome,noise_var=1){
prediction <- design %*% coef
residual <- outcome - prediction
return(drop(crossprod(design,residual)/noise_var))
}
lm_loglike_grad(beta,design,outcome)
lm_gradient(beta,design,outcome)
devtools::load_all(".")
lm_loglike_grad(beta,design,outcome)
lm_gradient(beta,design,outcome)
test_that(
"test for the gradient of log likelihood in linear model", {
n_obs = 32; n_pred = 4
data = simulate_data(n_obs, n_pred, model = 'linear', seed = 1918)
design = data$design; outcome = data$outcome
beta = c(3, 1, 4, 1)
analytical_grad <- lm_gradient(beta, design, outcome)
numerical_grad <- approx_grad(function(beta) lm_log_likelihood(beta, design, outcome), beta)
testthat::expect_true(
are_all_close(analytical_grad, numerical_grad, abs_tol = 1e-3, rel_tol = 1e-3)
)
}
)
ncol(design)
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
design
outcome
temp=lm_bfgs(design,outcome)
temp
lm_peudo_inv(design, outcome)
hglm_out$coef = lm_bfgs(design, outcome)
#TODO: implementation
hglm_out <- list()
class(hglm_out) <- "hglm"
if(model == "linear"){
if(is.null(option$mle_solver)){
hglm_out$coef = lm_peudo_inv(design, outcome)
}
if(option$mle_solver == "BFGS"){
hglm_out$coef = lm_bfgs(design, outcome)
}
}
lm_bfgs(design, outcome)
lm_peudo_inv(design, outcome)
optim(beta0, lm_log_likelihood, gr = lm_gradient,
design = design, outcome = outcome,
method = "BFGS", control=list(fnscale=-1))
n_pred = ncol(design)
beta0 = rep(0, n_pred)
beta_optim = optim(beta0, lm_log_likelihood, gr = lm_gradient,
design = design, outcome = outcome,
method = "BFGS", control=list(fnscale=-1))
beta_optim
beta_optim$par
devtools::load_all(".")
lm_bfgs(design, outcome)
option$mle_solver
option = list(mle_solver = 'BFGS')
option$mle_solver
option$mle_solver=='BFGS'
hiper_glm(
design, outcome, model = 'linear', option = list(mle_solver = 'BFGS')
)
hiper_glm(design, outcome, model = 'linear')
devtools::load_all(".")
